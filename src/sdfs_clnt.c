/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include "sdfs.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

READ_RSP_T *
rpc_read_0x0001(READ_REQ_T *argp, CLIENT *clnt)
{
	static READ_RSP_T clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_read,
		(xdrproc_t) xdr_READ_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_READ_RSP_T, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

WRITE_RSP_T *
rpc_write_0x0001(WRITE_REQ_T *argp, CLIENT *clnt)
{
	static WRITE_RSP_T clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_write,
		(xdrproc_t) xdr_WRITE_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_WRITE_RSP_T, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_open_0x0001(OPEN_REQ_T *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_open,
		(xdrproc_t) xdr_OPEN_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_create_0x0001(CREATE_REQ_T *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_create,
		(xdrproc_t) xdr_CREATE_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

GETATTR_RSP_T *
rpc_getattr_0x0001(GETATTR_REQ_T *argp, CLIENT *clnt)
{
	static GETATTR_RSP_T clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_getattr,
		(xdrproc_t) xdr_GETATTR_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_GETATTR_RSP_T, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

READDIR_RSP_T *
rpc_readdir_0x0001(READDIR_REQ_T *argp, CLIENT *clnt)
{
	static READDIR_RSP_T clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_readdir,
		(xdrproc_t) xdr_READDIR_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_READDIR_RSP_T, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_access_0x0001(ACCESS_REQ_T *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_access,
		(xdrproc_t) xdr_ACCESS_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_mknod_0x0001(MKNOD_REQ_T *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_mknod,
		(xdrproc_t) xdr_MKNOD_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_mkdir_0x0001(MKDIR_REQ_T *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_mkdir,
		(xdrproc_t) xdr_MKDIR_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_unlink_0x0001(char **argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_unlink,
		(xdrproc_t) xdr_wrapstring, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_rmdir_0x0001(char **argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_rmdir,
		(xdrproc_t) xdr_wrapstring, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_symlink_0x0001(SYMLINK_REQ_T *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_symlink,
		(xdrproc_t) xdr_SYMLINK_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_rename_0x0001(RENAME_REQ_T *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_rename,
		(xdrproc_t) xdr_RENAME_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_link_0x0001(LINK_REQ_T *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_link,
		(xdrproc_t) xdr_LINK_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_chmod_0x0001(CHMOD_REQ_T *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_chmod,
		(xdrproc_t) xdr_CHMOD_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_chown_0x0001(CHOWN_REQ_T *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_chown,
		(xdrproc_t) xdr_CHOWN_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_truncate_0x0001(TRUNCATE_REQ_T *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_truncate,
		(xdrproc_t) xdr_TRUNCATE_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

READLINK_RSP_T *
rpc_readlink_0x0001(READLINK_REQ_T *argp, CLIENT *clnt)
{
	static READLINK_RSP_T clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_readlink,
		(xdrproc_t) xdr_READLINK_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_READLINK_RSP_T, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

STATVFS_RSP_T *
rpc_statvfs_0x0001(char **argp, CLIENT *clnt)
{
	static STATVFS_RSP_T clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_statvfs,
		(xdrproc_t) xdr_wrapstring, (caddr_t) argp,
		(xdrproc_t) xdr_STATVFS_RSP_T, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_setxattr_0x0001(SETXATTR_REQ_T *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_setxattr,
		(xdrproc_t) xdr_SETXATTR_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

GETXATTR_RSP_T *
rpc_getxattr_0x0001(GETXATTR_REQ_T *argp, CLIENT *clnt)
{
	static GETXATTR_RSP_T clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_getxattr,
		(xdrproc_t) xdr_GETXATTR_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_GETXATTR_RSP_T, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

LISTXATTR_RSP_T *
rpc_listxattr_0x0001(LISTXATTR_REQ_T *argp, CLIENT *clnt)
{
	static LISTXATTR_RSP_T clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_listxattr,
		(xdrproc_t) xdr_LISTXATTR_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_LISTXATTR_RSP_T, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_removexattr_0x0001(REMOVEXATTR_REQ_T *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_removexattr,
		(xdrproc_t) xdr_REMOVEXATTR_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
rpc_fallocate_0x0001(FALLOCATE_REQ_T *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, rpc_fallocate,
		(xdrproc_t) xdr_FALLOCATE_REQ_T, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}
