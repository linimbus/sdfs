/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "sdfs.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <dirent.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/statvfs.h>
#include <pthread.h>
#include <attr/xattr.h>



typedef  struct membuf {
	char * pbuf;
	int size;
}MEM_BUF_S;

#define DEFINE_BUF(mbuf) static MEM_BUF_S mbuf = {NULL,0};

#define RENEW_BUF(mbuf, resize) \
	do { \
		resize = (resize < 4096 ) ? 4096 : resize; \
		if(mbuf.size < resize) \
		{ \
			if(mbuf.pbuf) \
				mbuf.pbuf = realloc(mbuf.pbuf, 2*resize); \
			else \
				mbuf.pbuf = malloc( 2*resize); \
			\
			if(NULL == mbuf.pbuf) \
			{ \
				printf("alloc failed!"); \
				exit(-1); \
			} \
			mbuf.size = 2*resize; \
		} \
	}while(0)

pthread_mutex_t m_lock = PTHREAD_MUTEX_INITIALIZER;

#define LOCK() (void)pthread_mutex_lock(&m_lock);
#define ULOCK() (void)pthread_mutex_unlock(&m_lock);

#define MAX_OPEN_NUM  1024
#define MAX_FILE_NAME 256



char g_stHome[MAX_FILE_NAME] = {'\0'};

#define ROOT_PATH g_stHome

int clnt_debug = 0 ;
int clnt_cnt = 0 ;

#define DEFINE_DIR() char rlpath[MAX_FILE_NAME];
#define DEFINE_DIR2(path1) char path1[MAX_FILE_NAME];

#define log(path) \
	if(clnt_debug) \
	{ \
		printf("No.%-3u [%s:%u] %s\r\n", clnt_cnt++, __FUNCTION__,__LINE__,path ); \
	}

#define RLDIR(path) \
	do { \
		char buf[MAX_FILE_NAME]; \
		(void)snprintf(rlpath,MAX_FILE_NAME,"%s%s",".",path); \
		log(rlpath); \
	}while(0)

#define RLDIR2(rlpath,path) \
	do { \
		char buf[MAX_FILE_NAME]; \
		(void)snprintf(rlpath,MAX_FILE_NAME,"%s%s",".",path); \
		log(rlpath); \
	}while(0)

#define DEBUG(rqstp) \
	if(clnt_debug > 1) \
	{ \
		printf("prog: %lu \r\n", rqstp->rq_prog); \
		printf("vers: %lu \r\n", rqstp->rq_vers); \
		printf("proc: %lu \r\n", rqstp->rq_proc); \
		printf("xprt: %p \r\n", rqstp->rq_xprt); \
	}

#define CHECKERR(err) \
	if(clnt_debug > 1) \
	{ \
		if ( err ) \
			printf("       [%s:%u] return errno %s\r\n", __FUNCTION__,__LINE__,strerror(err) ); \
		else \
			printf("       [%s:%u] return ok \r\n", __FUNCTION__,__LINE__ ); \
	}

READ_RSP_T *
rpc_read_0x0001_svc(READ_REQ_T *argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static READ_RSP_T  result;
	int fd;
	int ret;
	
	DEFINE_BUF(mbuf);
	RENEW_BUF(mbuf, argp->size);

	RLDIR(argp->path);
	DEBUG(rqstp);

	fd = open(rlpath,O_RDONLY);
	if(fd == -1) {
		result.err = -errno;
		CHECKERR(result.err);
		return &result;
	}else{
		result.err = 0;
	}

	ret = pread(fd,mbuf.pbuf,argp->size,argp->offset);
	if(ret == -1) {
		result.err = -errno;
	}else{
		result.err = 0;
	}

	(void)close(fd);

	result.data.data_val = mbuf.pbuf;
	result.data.data_len = ret;
	result.size = ret;

	CHECKERR(result.err);

	return &result;
}

WRITE_RSP_T *
rpc_write_0x0001_svc(WRITE_REQ_T *argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static WRITE_RSP_T  result;
	int fd, ret;

	RLDIR(argp->path);
	DEBUG(rqstp);

	fd = open(rlpath,O_WRONLY);
	if(fd == -1) {
		result.err = -errno;
		CHECKERR(result.err);
		return &result;
	}else{
		result.err = 0;
	}

	ret = pwrite(fd, argp->data.data_val,argp->data.data_len, argp->offset );
	if(ret == -1) {
		result.err = -errno;
	}else{
		result.err = 0;
		result.size = ret;
	}

	(void)close(fd);

	CHECKERR(result.err);

	return &result;
}

int *
rpc_open_0x0001_svc(OPEN_REQ_T *argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static int  result;
	int fd;

	RLDIR(argp->path);
	DEBUG(rqstp);

	fd = open(rlpath, argp->flag );
	if(fd == -1) {
		result = -errno;
	}else{
		result = 0;
		(void)close(fd);
	}

	CHECKERR(result);
	return &result;
}

int *
rpc_create_0x0001_svc(CREATE_REQ_T *argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static int  result;
	int fd;

	RLDIR(argp->path);
	DEBUG(rqstp);

	fd = open(rlpath, argp->flag, argp->mode);
	if(fd == -1) {
		result = -errno;
	}else{
		result = 0;
		(void)close(fd);
	}

	CHECKERR(result);
	return &result;
}

GETATTR_RSP_T *
rpc_getattr_0x0001_svc(GETATTR_REQ_T *argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static GETATTR_RSP_T  result;
	struct stat stbuf;
	int ret;

	RLDIR(argp->path);
	DEBUG(rqstp);

	ret = lstat(rlpath,&stbuf);
	if(ret == -1) {
		result.err = -errno;
		CHECKERR(result.err);
		return &result;
	}

	result.err = 0;

	result.mode = stbuf.st_mode;
	result.nlink = stbuf.st_nlink;
	result.size = stbuf.st_size;
	result.ino = stbuf.st_ino;
	result.uid = stbuf.st_uid;
	result.gid = stbuf.st_gid;
	result.atime = stbuf.st_atime;
	result.mtime = stbuf.st_mtime;
	result.ctime = stbuf.st_ctime;

	CHECKERR(result.err);
	return &result;
}

READDIR_RSP_T *
rpc_readdir_0x0001_svc(READDIR_REQ_T *argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static READDIR_RSP_T  result;
	DIR * dp;
	struct dirent * de;
	int remainsize;
	int usedsize;

	DEFINE_BUF(mbuf);
	RENEW_BUF(mbuf, argp->size);

	remainsize = mbuf.size - 1;
	usedsize = 0;
	

	RLDIR(argp->path);
	DEBUG(rqstp);

	dp = opendir(rlpath);
	if(dp == NULL) 
	{
		result.err = -errno;
		CHECKERR(result.err);
		return &result;
	}

	seekdir(dp , argp->offset);
	result.err = 0;

	while((de = readdir(dp)) != NULL )
	{
		int len = strlen(de->d_name) + 1;

		if ( remainsize < len ) 
		{
			remainsize = 2 * mbuf.size;
			RENEW_BUF(mbuf, remainsize );
			remainsize = mbuf.size - 1;
		}

		snprintf(mbuf.pbuf + usedsize, remainsize, "%s\n" , de->d_name );

		remainsize -= len;
		usedsize += len;
	}

	result.size = usedsize;
	result.data.data_len = usedsize;
	result.data.data_val = mbuf.pbuf;
	
	closedir(dp);

	CHECKERR(result.err);
	return &result;
}

int *
rpc_access_0x0001_svc(ACCESS_REQ_T *argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static int  result;
	int ret;

	RLDIR(argp->path);
	DEBUG(rqstp);

	ret = access(rlpath, argp->mask);
	if(ret == -1) {
		result = -errno;
	}else{
		result = 0;
	}

	CHECKERR(result);
	return &result;
}

int *
rpc_mknod_0x0001_svc(MKNOD_REQ_T *argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static int  result;
	int ret;

	RLDIR(argp->path);
	DEBUG(rqstp);

	if (S_ISFIFO(argp->mode))
		ret = mkfifo(rlpath, argp->mode);
	else
		ret = mknod(rlpath, argp->mode, argp->dev);
	
	if(ret == -1) {
		result = -errno;
	}else{
		result = 0;
	}

	CHECKERR(result);
	return &result;
}

int *
rpc_mkdir_0x0001_svc(MKDIR_REQ_T *argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static int  result;
	int ret;

	RLDIR(argp->path);
	DEBUG(rqstp);

	ret = mkdir(rlpath, argp->mode);
	if(ret == -1) {
		result = -errno;
	}else{
		result = 0;
	}

	CHECKERR(result);
	return &result;
}

int *
rpc_unlink_0x0001_svc(char **argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static int  result;
	int ret;

	RLDIR(*argp);
	DEBUG(rqstp);

	ret = unlink(rlpath);
	if(ret == -1) {
		result = -errno;
	}else{
		result = 0;
	}

	CHECKERR(result);
	return &result;
}

int *
rpc_rmdir_0x0001_svc(char **argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static int  result;
	int ret;

	RLDIR(*argp);
	DEBUG(rqstp);

	ret = rmdir(rlpath);
	if(ret == -1) {
		result = -errno;
	}else{
		result = 0;
	}

	CHECKERR(result);
	return &result;
}

int *
rpc_symlink_0x0001_svc(SYMLINK_REQ_T *argp, struct svc_req *rqstp)
{
        DEFINE_DIR2(rlfrom);
	DEFINE_DIR2(rlto);
	static int  result;
	int ret;

	RLDIR2(rlfrom,argp->from);
	RLDIR2(rlto,argp->to);

	DEBUG(rqstp);

	ret = symlink(rlfrom, rlto);
	if(ret == -1) {
		result = -errno;
	}else{
		result = 0;
	}

	CHECKERR(result);
	return &result;
}

int *
rpc_rename_0x0001_svc(RENAME_REQ_T *argp, struct svc_req *rqstp)
{
        DEFINE_DIR2(rlfrom);
	DEFINE_DIR2(rlto);
	static int  result;
	int ret;

	RLDIR2(rlfrom,argp->from);
	RLDIR2(rlto,argp->to);

	DEBUG(rqstp);

	ret = rename(rlfrom, rlto);
	if(ret == -1) {
		result = -errno;
	}else{
		result = 0;
	}

	CHECKERR(result);
	return &result;
}

int *
rpc_link_0x0001_svc(LINK_REQ_T *argp, struct svc_req *rqstp)
{
        DEFINE_DIR2(rlfrom);
	DEFINE_DIR2(rlto);
	static int  result;
	int ret;

	RLDIR2(rlfrom,argp->from);
	RLDIR2(rlto,argp->to);

	DEBUG(rqstp);

	ret = link(rlfrom, rlto);
	if(ret == -1) {
		result = -errno;
	}else{
		result = 0;
	}

	CHECKERR(result);
	return &result;
}

int *
rpc_chmod_0x0001_svc(CHMOD_REQ_T *argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static int  result;
	int ret;

	RLDIR(argp->path);

	DEBUG(rqstp);

	ret = chmod(rlpath, argp->mode);
	if(ret == -1) {
		result = -errno;
	}else{
		result = 0;
	}

	CHECKERR(result);
	return &result;
}

int *
rpc_chown_0x0001_svc(CHOWN_REQ_T *argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static int  result;
	int ret;

	RLDIR(argp->path);
	DEBUG(rqstp);

	ret = lchown(rlpath, argp->uid, argp->gid);
	if(ret == -1) {
		result = -errno;
	}else{
		result = 0;
	}

	CHECKERR(result);
	return &result;
}

int *
rpc_truncate_0x0001_svc(TRUNCATE_REQ_T *argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static int  result;
	int ret;

	RLDIR(argp->path);
	DEBUG(rqstp);

	ret = truncate(rlpath, argp->size);
	if(ret == -1) {
		result = -errno;
	}else{
		result = 0;
	}

	CHECKERR(result);
	return &result;
}

READLINK_RSP_T *
rpc_readlink_0x0001_svc(READLINK_REQ_T *argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static READLINK_RSP_T  result;

	RLDIR(argp->path);
	DEBUG(rqstp);

	// TBD

	return &result;
}

STATVFS_RSP_T *
rpc_statvfs_0x0001_svc(char **argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static STATVFS_RSP_T  result;
	struct statvfs stbuf;
	int ret;

	RLDIR(*argp);
	DEBUG(rqstp);

	memset(&stbuf,0,sizeof(struct statvfs));

	ret = statvfs(rlpath, &stbuf);
	if(ret == -1) {
		result.err = -errno;
	}else{
		result.err = 0;
	}

	result.bsize  = stbuf.f_bsize;
	result.frsize = stbuf.f_frsize;
	result.blocks = stbuf.f_blocks;
	result.bfree  = stbuf.f_bfree;
	result.bavail = stbuf.f_bavail;
	result.files  = stbuf.f_files;
	result.ffree  = stbuf.f_ffree;
	result.favail = stbuf.f_favail;
	result.fsid   = stbuf.f_fsid;
	result.flag   = stbuf.f_flag;
	result.namemax = stbuf.f_namemax;

	CHECKERR(result.err);
	return &result;
}

int *
rpc_setxattr_0x0001_svc(SETXATTR_REQ_T *argp, struct svc_req *rqstp)
{
    DEFINE_DIR();
	static int  result;
	int ret;

	RLDIR(argp->path);
	DEBUG(rqstp);

	ret = lsetxattr(rlpath,
			argp->name, 
			argp->value.value_val, 
			argp->value.value_len, 
			argp->flag);
	if(ret == -1) {
		result = -errno;
	}else{
		result = 0;
	}

	CHECKERR(result);
	return &result;
}

GETXATTR_RSP_T *
rpc_getxattr_0x0001_svc(GETXATTR_REQ_T *argp, struct svc_req *rqstp)
{
	DEFINE_DIR();
	static GETXATTR_RSP_T  result;
	int ret;

	DEFINE_BUF(mbuf);
	RENEW_BUF(mbuf, argp->size);

	RLDIR(argp->path);
	DEBUG(rqstp);

	ret = lgetxattr(rlpath, argp->name, mbuf.pbuf, argp->size);
	if(ret == -1) {
		result.err = -errno;
	}else{
		result.err = 0;
	}

	result.value.value_len = argp->size;
	result.value.value_val = mbuf.pbuf;

	CHECKERR(result.err);
	return &result;
}

LISTXATTR_RSP_T *
rpc_listxattr_0x0001_svc(LISTXATTR_REQ_T *argp, struct svc_req *rqstp)
{
	DEFINE_DIR();
	static LISTXATTR_RSP_T  result;
	int ret;

	DEFINE_BUF(mbuf);
	RENEW_BUF(mbuf, argp->size);

	RLDIR(argp->path);
	DEBUG(rqstp);

	ret = llistxattr(rlpath, mbuf.pbuf, argp->size);
	if(ret == -1) {
		result.err = -errno;
	}else{
		result.err = 0;
	}

	result.value.value_len = argp->size;
	result.value.value_val = mbuf.pbuf;

	CHECKERR(result.err);
	return &result;
}

int *
rpc_removexattr_0x0001_svc(REMOVEXATTR_REQ_T *argp, struct svc_req *rqstp)
{
	DEFINE_DIR();
	static int  result;
	int ret;

	RLDIR(argp->path);
	DEBUG(rqstp);

	ret = lremovexattr(rlpath, argp->name);
	if(ret == -1) {
		result = -errno;
	}else{
		result = 0;
	}

	CHECKERR(result);
	return &result;
}

int *
rpc_fallocate_0x0001_svc(FALLOCATE_REQ_T *argp, struct svc_req *rqstp)
{
	DEFINE_DIR();
	static int  result;

	result = -EOPNOTSUPP;

	RLDIR(argp->path);
	DEBUG(rqstp);
	
	// TBD

	return &result;
}


void parse_cmd(int argc ,char **argv )
{
	int i;
	
	for( i = 1 ; i < argc ; i++ )
	{
		if (strstr(argv[i], "-d") || strstr(argv[i], "--debug")  )
		{
			clnt_debug = 2;
			printf("DEBUG MODE!\r\n");
		}
	}
}


